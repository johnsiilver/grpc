![grpc logo](https://raw.githubusercontent.com/cncf/artwork/master/projects/grpc/horizontal/color/grpc-horizontal-color.png)
---
[![GoDev](https://img.shields.io/static/v1?label=godev&message=reference&color=00add8)](https://pkg.go.dev/github.com/johnsiilver/grpc/server)

These packages provide convienence wrappers around the Golang GRPC and GRPC Gateway projects.

There are two main packages:
- gateway/client - provides a REST client to GRPC when using grpc-gateway
- server - provides a GRPC runner that can mux GRPC/REST/HTTP on the same port and other helpful tidbits

## Why I Did This

I developed/developing a package that allows me to write pure Go + CSS, nothing else.

For that project, I wanted to use GRPC from WASM, but the GRPC client won't run in WASM. This whole Envoy provy for that purpose(https://github.com/grpc/grpc-web) only makes sense to me when you have a team maintaing proxies for a company. The simplest solution is the GRPC Gateway REST endpoint.  

However, if you use REST and serve WASM on different ports, you now have to deal with CORS. I don't want to deal with CORS (simplicity makes for reliable services and is surprisingly hard to do).

So this solves those problems and provides some sane defaults around things like having at least gzip compression and easy ways to do http.Handler wrapping for middleware.

## Packages

### gateway/client

This simply makes a REST client (if you are using the GRPC Gateway) that supports:
- The service package by tagging the request header "Content-Type": "application/grpc-gateway"
- Automatic marshal/unmarshal from JSON into Protocol Buffers
- Requests gzip/deflate responses by default (if the REST server supports it)
- Can provides gzip/deflate request compression (if the REST server supports it) with a simple option
- Easily add your own compression/decompression
- Provide your own custom *http.Client as an option
- A simple calling mechanism

Note: This uses the new [Go protocol buffer library](https://blog.golang.org/protobuf-apiv2). I'm
not sure if this will work with protos generated by the older compiler. You may need a compiler that is in the > 1.4.x family from [here](https://github.com/golang/protobuf/). Instructions for installation are [here](https://grpc.io/docs/languages/go/quickstart/).

### server

Provides a wrapper that provides:
- Routing of GRPC/REST/HTTP traffic on a single port
- Applying TLS for all services, if you want it
- Allows using GRPC and other HTTP services on non-TLS connections using H2C (which is a pain to figure out you need)
- REST Gateway to GRPC setup
- Applying common HTTP handler wrappers to the Gateway and HTTP handlers
- Applying gzip compression of HTTP/REST responses by default if client supports it unless otherwise configured
- Applying gzip compression of GRPC responses by default unless otherwise configured
- STAYING OUT OF THE WAY to allow you to customize your GRPC server, REST Gateway and HTTP

## Potential FAQs

### Can I contribute?

Yes, with caveats. Unless it is a bug fix, please send an email on what you propose before writing code. The goal here is simplicity and some use cases are better handled with by just forking the code for your own purposes.

### The release is v0.x.x, can we use it?

While we are still doing v0.x releases, it is possible that I will break the API. So you should tag to specific releases and not rely on the master branch.

### Why Gzip defaults instead of X

While I'm not sure which compression tech X will be, the answer would be the same. gzip is just universally supported.

I'm a fan of brotil myself, but:

- brotil requires HTTPS
- Many things don't support it
- The Go version requires CGO, which means NAY!!!!
- Yeah I know dsnet has one, but its not production ready

### In the server you provide default gzip/deflate compressors/decompressors, can I override them?

Yes, if you provide a faster compress/decompressor for encoding types "gzip" or "deflate" it will override the ones provided.

### You haven't updated this project in a while, still safe?

Unless I get bug requests, feature requests or I need something, I leave good code alone.

I try to respond to issues within a reasonable amount of time (a week), but remember that this is free code and I already have a job, go on vacations (when there isn't COVID), etc...

