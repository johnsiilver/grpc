/*
Package client provides a REST client for communicating with a GRPC gateway. This client is
specifically made to work with github.com/johnsiilver/grpc/server .

If not using with our server, you need to use:
	- Use the CustomHeaders() in order to remove "Content-Type": "application/grpc-gateway"
	- Pass CompressRequests(nil) to remove gzip compression, unless your server supports it

Usage example:
	u, err := url.Parse("http://208.244.233.1:8080")
	if err != nil {
		// Do something
	}

	resty := New(u)

	resp := &pb.YourResp{}

	err = resty.Call(
		context.Background(),
		"/v1/snippetsService/save", // This is the URL of the REST call, defined in your proto file
		&pb.YourReq{...}, // The protocol buffer you are sending
		resp, // The protocol buffer message you should receive
	)
	if err != nil {
		// Do something
	}
*/
package client

import (
	"log"
	"bytes"
	"compress/flate"
	"compress/gzip"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

// ContentType is the HTTP request header's content type for requests going to the grpc-gateway.
// If you are binding multiple services listeners to a port, you will need to route requests with
// this content-type to your runtime.ServeMux.
const ContentType = "application/grpc-gateway"

// DefaultHeaders returns the default headers used in our GRPC REST client. It is recommended that
// if you want to apply custom headers, you modify a header generated by this function.
func DefaultHeaders() http.Header {
	h := http.Header{}
	h.Add("Content-Type", ContentType)
	return h
}

// GRPC is a REST client for talking with a GRPC gateway. The backend handlers will receive
// content-type: application/grpc-gateway.
type GRPC struct {
	base   *url.URL
	client *http.Client
	header http.Header

	compressHandler Compressor

	decompressHandlers map[string]Decompressor
	acceptEncoding     []string
}

// Compressor creates an *http.Request that compresses the Body content. The path is the
// URL path, headers are the request headers and r is the io.Reader that we will write the
// request body with.
type Compressor func(ctx context.Context, path string, headers http.Header, r io.Reader) (*http.Request, error)

// Decompressor takes an io.Reader returns an io.Reader that decompresses the content.
type Decompressor func(r io.Reader) io.Reader

// Option provides an optional argument to the New() constructor.
type Option func(g *GRPC)

// CustomClient allows providing a custom http client for contacting GRPC's gateway proxy.
// By default, we use a client with defaults set (we do not use the built in client).
func CustomClient(h *http.Client) Option {
	return func(g *GRPC) {
		g.client = h
	}
}

// CustomHeaders provides a custom header to be sent on each call. The default headers set only one value,
// "content-type", which is set to the constant ContentType defined in this file. This is also
// useful for setting JS Fetch() call options when doing WASM:
// https://github.com/golang/go/wiki/WebAssembly#configuring-fetch-options-while-using-nethttp
func CustomHeaders(header http.Header) Option {
	return func(g *GRPC) {
		g.header = header
	}
}

// CompressRequests will compress all http.Request.Body content with the Compression handler provided
// here. The REST service will need need to be able to understand the Content-Encoding
// and decompress it before grpc-gateway receives the message.
func CompressRequests(h Compressor) Option {
	return func(g *GRPC) {
		g.compressHandler = h
	}
}

// DecompressResponse allows decompression of responses sent from the server with the "acceptEncoding" using
// the provided Decompressor. By default, we already support gzip("gzip") and deflate("deflate").
// You may provide this option multiple times for multiple acceptEncodings. Because servers tend to
// decompress based on order in the Accept-Encoding array, the order is important. The first use of
// this will be the first Accept-Encoding in the array (gzip, defalte will always be at the end).
// If using our server, it will choose to encode the response in whatever the request is encoded in first
// and then in its own preference order.
func DecompressResponse(acceptEncoding string, h Decompressor) Option {
	return func(g *GRPC) {
		g.decompressHandlers[acceptEncoding] = h
		g.acceptEncoding = append(g.acceptEncoding, acceptEncoding)
	}
}

// New is the constructor for talking with the GRPC gateway. endpoint is a url that starts with
// http/https and ends with :port (https://192.168.1.1:8082) representing the grpc-gateway endpoint.
func New(endpoint *url.URL, options ...Option) *GRPC {
	g := &GRPC{
		base:            endpoint,
		client:          &http.Client{},
		header:          DefaultHeaders(),
		decompressHandlers: map[string]Decompressor{
			"gzip":    gzipDecompress,
			"deflate": defalteDecompress,
		},
	}

	for _, o := range options {
		o(g)
	}

	for _, enc := range g.acceptEncoding {
		g.header.Add("Accept-Encoding", enc)
	}
	// These are here so that if they provided custom decoding that we are giving the server
	// preference for them over gzip/deflate.
	g.header.Add("Accept-Encoding", "gzip")
	g.header.Add("Accept-Encoding", "deflate")

	return g
}

// Call calls a non-streaming RPC at path, where path is the relative URL of the call (/v1/snippetsService/save).
// Args is the proto message that will be sent and result is the proto message that is expected to be returned.
// Call will honor timeouts and cancels from the Context object.
func (g *GRPC) Call(ctx context.Context, path string, args proto.Message, result proto.Message) error {
	b, err := protojson.Marshal(args)
	if err != nil {
		return fmt.Errorf("grpc.Call(): %T could not be json marshalled: %w", args, err)
	}

	ref, err := url.Parse(path)
	if err != nil {
		return fmt.Errorf("grpc.Call(): could not parse path URL(%s): %w", path, err)
	}

	fullPath := g.base.ResolveReference(ref).String()

	var req *http.Request
	// Apply compression to request body if needed.
	if g.compressHandler != nil {
		req, err = g.compressHandler(ctx, fullPath, g.header, bytes.NewBuffer(b))
		if err != nil {
			return fmt.Errorf("grpc.Call(): failed to create a request: %w", err)
		}
	} else {
		log.Println("sending: ", string(b))
		req, err = http.NewRequestWithContext(ctx, "POST", fullPath, bytes.NewBuffer(b))
		if err != nil {
			return fmt.Errorf("grpc.Call(): failed to create a request: %w", err)
		}
		req.Header = g.header
	}

	resp, err := g.client.Do(req)
	if err != nil {
		return fmt.Errorf("grpc.Call(): client had error connecting to service: %w", err)
	}

	if resp.StatusCode != 200 {
		content, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf("grpc.Call(): service returned a non-200 status code(%d): %s", resp.StatusCode, string(content))
	}

	// Decompress response, if needed.
	reader, err := g.handleDecompress(resp)
	if err != nil {
		return fmt.Errorf("grpc.Call(): client had error finding a decompressor: %w", err)
	}

	content, err := ioutil.ReadAll(reader)
	if err != nil {
		return fmt.Errorf("grpc.Call(): client had error reading response: %w", err)
	}

	if err := protojson.Unmarshal(content, result); err != nil {
		return fmt.Errorf("grpc.Call(%s): had error unmarshalling response body into %T: %w", path, result, err)
	}
	return nil
}

// handleDecompress looks at the Content-Encoding and provides the appropriate decompressor if
// we have one.
func (g *GRPC) handleDecompress(resp *http.Response) (io.Reader, error) {
	// This field indicates that our client uncompressed the response for us by default.
	// This is only set when the server does this, it is not an overall indication if the response
	// is uncompressed.
	if resp.Uncompressed {
		return resp.Body, nil
	}

	ce := resp.Header.Get("Content-Encoding")
	if ce == "" {
		return resp.Body, nil
	}

	handler := g.decompressHandlers[ce]
	if handler == nil {
		return nil, fmt.Errorf("rest.GRPC.Call(): received Content-Encoding %s, which we do not support", ce)
	}

	return handler(resp.Body), nil
}

// GzipCompress implements Compressor to allow compressing requests to the server.
func GzipCompress(ctx context.Context, path string, headers http.Header, r io.Reader) (*http.Request, error) {
	pipeOut, pipeIn := io.Pipe()
	w := gzip.NewWriter(pipeIn)

	go func() {
		_, err := io.Copy(w, r)
		if err != nil {
			pipeIn.CloseWithError(err)
			w.Close()
			return
		}
		if err := w.Close(); err != nil {
			pipeIn.CloseWithError(err)
			return
		}
		pipeIn.Close()
	}()

	req, err := http.NewRequestWithContext(ctx, "POST", path, pipeOut)
	if err != nil {
		return nil, err
	}
	if headers != nil {
		req.Header = headers
	}
	req.Header.Add("Content-Encoding", "gzip")

	return req, nil
}

// gzipDecompress implements Decompressor for decompressing gzip content.
func gzipDecompress(r io.Reader) io.Reader {
	gzipReader, _ := gzip.NewReader(r)

	pipeOut, pipeIn := io.Pipe()
	go func() {
		_, err := io.Copy(pipeIn, gzipReader)
		if err != nil {
			pipeIn.CloseWithError(err)
			gzipReader.Close()
			return
		}
		if err := gzipReader.Close(); err != nil {
			pipeIn.CloseWithError(err)
			return
		}
		pipeIn.Close()
	}()
	return pipeOut
}

// defalteDecompress implements Decompressor for decompressing deflate content.
func defalteDecompress(r io.Reader) io.Reader {
	flateReader := flate.NewReader(r)

	pipeOut, pipeIn := io.Pipe()
	go func() {
		_, err := io.Copy(pipeIn, flateReader)
		if err != nil {
			pipeIn.CloseWithError(err)
			flateReader.Close()
			return
		}
		if err := flateReader.Close(); err != nil {
			pipeIn.CloseWithError(err)
			return
		}
		pipeIn.Close()
	}()
	return pipeOut
}
